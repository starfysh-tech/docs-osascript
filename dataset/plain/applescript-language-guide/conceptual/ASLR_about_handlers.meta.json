{
  "collection": "applescript-language-guide",
  "path": "conceptual/ASLR_about_handlers.md",
  "title": "About Handlers",
  "body": "<a id=\"//apple_ref/doc/uid/TP40000983-CH206-CJBIDBJH\"></a>\n\n# About Handlers\n\n<a id=\"//apple_ref/doc/uid/TP40000983-CH206-DontLinkElementID_229\"></a>When script developers want to factor and re-use their code, they can turn to handlers. A handler is a collection of statements that can be invoked by name. Handlers are also known as functions, subroutines, or methods.\n\nThis chapter describes how to work with handlers, in the following sections:\n\n* [Handler Basics](#//apple_ref/doc/uid/TP40000983-CH206-SW3)\n* [Handlers in Script Applications](#//apple_ref/doc/uid/TP40000983-CH206-SW14)\n\nFor detailed reference information, see [Handler Reference](../reference/ASLR_handlers.md#//apple_ref/doc/uid/TP40000983-CH7g-163762).\n\n<a id=\"//apple_ref/doc/uid/TP40000983-CH206-SW3\"></a>\n\n## Handler Basics\n\n<a id=\"//apple_ref/doc/uid/TP40000983-CH206-DontLinkElementID_230\"></a>A *handler* is a collection of statements that can be invoked by name. Handlers are useful in scripts that perform the same action in more than one place. You can package statements that perform a specific task as a handler, give it a descriptive name, and call it from anywhere in the script. This makes the script shorter and easier to maintain.\n\nA script can contain one or more handlers. However, you can not nest a handler definition within another handler (although a script object defined in a handler can contain other handlers).\n\nThe definition for a handler specifies the parameters it uses, if any, and may specify a class or classes for the parameter and a default value.\n\nWhen you call a handler, you must list its parameters according to how they are specified in its definition. Handlers may have labeled, positional, or interleaved parameters, described in subsequent sections. If a parameter has a specified class, AppleScript will coerce the actual value to that class as if using the `as` operator. If a parameter has a default value, that parameter may be omitted.\n\nA handler definition can contain variable declarations and statements. It may use a `return` statement (described in detail in `return`) to return a value and exit the handler<a id=\"//apple_ref/doc/uid/TP40000983-CH206-DontLinkElementID_231\"></a>.\n\nThe sections that follow provide additional information on working with handlers:\n\n* [Defining a Simple Handler](#//apple_ref/doc/uid/TP40000983-CH206-SW23)\n* [Handlers with Labeled Parameters](#//apple_ref/doc/uid/TP40000983-CH206-SW22)\n* [Handlers with Positional Parameters](#//apple_ref/doc/uid/TP40000983-CH206-SW13)\n* [Handlers with Patterned Positional Parameters](#//apple_ref/doc/uid/TP40000983-CH206-SW20)\n* [Recursive Handlers](#//apple_ref/doc/uid/TP40000983-CH206-SW11)\n* [Errors in Handlers](#//apple_ref/doc/uid/TP40000983-CH206-SW10)\n* [Passing by Reference Versus Passing by Value](#//apple_ref/doc/uid/TP40000983-CH206-SW4)\n* [Calling Handlers in a tell Statement](#//apple_ref/doc/uid/TP40000983-CH206-SW1)\n\n<a id=\"//apple_ref/doc/uid/TP40000983-CH206-SW23\"></a>\n\n### Defining a Simple Handler\n\n<a id=\"//apple_ref/doc/uid/TP40000983-CH206-DontLinkElementID_232\"></a>The following is a definition for a simple handler that takes any parameter value that can be displayed as text (presumably one representing a date) and displays it in a dialog box. The handler name is `rock`; its parameter is `around the clock`, where `around` is a parameter label and `clock` is the parameter name (`the` is an AppleScript filler for readability):\n\n```\non rock around the clock\n    display dialog (clock as text)\nend rock\n```\n\nThis handler allows an English-like calling statement:\n\n```\nrock around the current date -- call handler to display current date\n```\n\nA handler can have no parameters. To indicate that a handler has no parameters, you include a pair of empty parentheses after the handler name in both the handler definition and the handler call. For example, the following `helloWorld` script has no parameters.<a id=\"//apple_ref/doc/uid/TP40000983-CH206-DontLinkElementID_233\"></a>\n\n```\non helloWorld()\n    display dialog \"Hello World\"\nend\n \nhelloWorld() -- Call the handler\n```\n\n<a id=\"//apple_ref/doc/uid/TP40000983-CH206-SW22\"></a>\n\n### Handlers with Labeled Parameters\n\n<a id=\"//apple_ref/doc/uid/TP40000983-CH206-DontLinkElementID_234\"></a><a id=\"//apple_ref/doc/uid/TP40000983-CH206-DontLinkElementID_235\"></a>To define a handler with labeled parameters, you list the labels to use when calling the handler and the statements to be executed when it is called. (The syntax is shown in [Handler Syntax (Labeled Parameters)](../reference/ASLR_handlers.md#//apple_ref/doc/uid/TP40000983-CH7g-SW2).)\n\nHandlers with labeled parameters can also have a direct parameter. With the exception of the direct parameter, which must directly follow the handler name, labeled parameters can appear in any order, with the labels from the handler definition identifying the parameter values. This includes parameters listed in `given`, `with`, and `without` clauses (of which there can be any number).\n\nThe `findNumbers` handler in the following example uses the special label `given` to define a parameter with the label `given rounding`.\n\n```\nto findNumbers of numberList above minLimit given rounding:roundBoolean\n        set resultList to {}\n        repeat with i from 1 to (count items of numberList)\n            set x to item i of numberList\n            if roundBoolean then -- round the number\n                -- Use copy so original list isn’t modified.\n                copy (round x) to x\n            end if\n            if x &gt; minLimit then\n                set end of resultList to x\n            end if\n        end repeat\n        return resultList\nend findNumbers\n```\n\nThe next statements show how to call `findNumbers` by passing a predefined `list` variable:\n\n```\nset myList to {2, 5, 19.75, 99, 1}\nfindNumbers of myList above 19 given rounding:true\n    --result: {20, 99}\nfindNumbers of myList above 19 given rounding:false\n    --result: {19.75, 99}\n```\n\nYou can also specify the value of the `rounding` parameter by using a `with` or `without` clause to indicate `true` or `false`. (In fact, when you compile the previous examples, AppleScript automatically converts `given rounding:true` to `with rounding` and `given rounding:false` to `without rounding`.) These examples pass a `list` object directly, rather than using a `list` variable as in the previous case:\n\n```\nfindNumbers of {5.1, 20.1, 20.5, 33} above 20 with rounding\n    --result: {33}\n \nfindNumbers of {5.1, 20.1, 20.5, 33.7} above 20 without rounding\n    --result: {20.1, 20.5, 33.7}\n```\n\nHere is another handler that uses parameter labels:\n\n```\nto check for yourNumber from startRange thru endRange\n    if startRange ≤ yourNumber and yourNumber ≤ endRange then\n        display dialog \"Congratulations! Your number is included.\"\n    end if\nend check\n```\n\nThe following statement calls the handler, causing it to display the `\"Congratulations!\"` message\n\n```\ncheck for 8 from 7 thru 10 -- call the handler\n```\n\n<a id=\"//apple_ref/doc/uid/TP40000983-CH206-SW13\"></a>\n\n### Handlers with Positional Parameters\n\n<a id=\"//apple_ref/doc/uid/TP40000983-CH206-DontLinkElementID_236\"></a><a id=\"//apple_ref/doc/uid/TP40000983-CH206-DontLinkElementID_237\"></a>The definition for a handler with positional parameters shows the order in which to list parameters when calling the handler and the statements to be executed when the handler is called. The definition must include parentheses, even if it doesn’t include any parameters. The syntax is shown in [Handler Syntax (Positional Parameters)](../reference/ASLR_handlers.md#//apple_ref/doc/uid/TP40000983-CH7g-166812).\n\nIn the following example, the `minimumValue` routine returns the smaller of two values:\n\n```\non minimumValue(x, y)\n    if x &lt; y then\n        return x\n    else\n        return y\n    end if\nend minimumValue\n \n-- To call minimumValue:\nminimumValue(5, 105) --result: 5\n```\n\nThe first line of the `minimumValue` handler specifies the parameters of the handler. To call a handler with positional parameters you list the parameters in the same order as they are specified in the handler definition.\n\nIf a handler call is part of an expression, AppleScript uses the value returned by the handler to evaluate the expression. For example, to evaluate the following expression, AppleScript first calls `minimumValue`, then evaluates the rest of the expression.\n\n```\nminimumValue(5, 105) + 50 --result: 55\n```\n\n<a id=\"//apple_ref/doc/uid/TP40000983-CH206-SW20\"></a>\n\n### Handlers with Patterned Positional Parameters\n\n<a id=\"//apple_ref/doc/uid/TP40000983-CH206-DontLinkElementID_238\"></a><a id=\"//apple_ref/doc/uid/TP40000983-CH206-DontLinkElementID_239\"></a>You can create a handler whose positional parameters define a pattern to match when calling the handler. For example, the following handler takes a single parameter whose pattern consists of two items in a list:\n\n```\non displayPoint({x, y})\n    display dialog (\"x = \" & x & \", y = \" & y)\nend displayPoint\n \n-- Calling the handler:\nset testPoint to {3, 8}\ndisplayPoint(testPoint)\n```\n\nA parameter pattern can be much more complex than a single list. The handler in the next example takes two numbers and a record whose properties include a list of bounds. The handler displays a dialog box summarizing some of the passed information.\n\n```\non hello(a, b, {length:l, bounds:{x, y, w, h}, name:n})\n    set q to a + b\n \n    set response to \"Hello \" & n & \", you  are \" & l & ¬\n        \" inches tall and occupy position (\" & x &  \", \" & y & \").\"\n \n    display dialog response\n \nend hello\n \nset thing to {bounds:{1, 2, 4, 5}, name:\"George\", length:72}\nhello (2, 3, thing)\n--result: A dialog displaying “Hello George, you are 72 inches  tall\n--          and occupy position (1,2).”\n```\n\nThe properties of a record passed to a handler with patterned parameters don’t have to be given in the same order in which they are given in the handler’s definition, as long as all the properties required to fit the pattern are present.\n\nThe following call to `minimumValue` uses the value from a handler call to `maximumValue` as its second parameter. The `maximumValue` handler (not shown) returns the larger of two passed numeric values.\n\n```\nminimumValue(20, maximumValue(1, 313)) --result: 20\n```\n\n<a id=\"//apple_ref/doc/uid/TP40000983-CH206-SW2\"></a>\n\n### Handlers with Interleaved Parameters\n\n<a id=\"//apple_ref/doc/uid/TP40000983-CH206-DontLinkElementID_240\"></a><a id=\"//apple_ref/doc/uid/TP40000983-CH206-DontLinkElementID_241\"></a>A handler with interleaved parameters is a special case of one with positional parameters. The definition shows the order in which to list parameters when calling the handler and the statements to be executed when the handler is called, but the name of the handler is broken into pieces and interleaved with the parameters, which can make it easier to read. Handlers with interleaved parameters may be used in any script, but are especially useful with bridged Objective-C methods, since they naturally resemble Objective-C syntax. The syntax is shown in [Handler Syntax (Interleaved Parameters)](../reference/ASLR_handlers.md#//apple_ref/doc/uid/TP40000983-CH7g-SW4).\n\nA handler with interleaved parameters may have only one parameter, as in this example:\n\n```\non areaOfCircleWithRadius:radius\n    return radius ^ 2 * pi\nend areaOfCircleWithRadius:\n```\n\nOr more than one, as in this example:\n\n```\non areaOfRectangleWithWidth:w height:h\n    return w * h\nend areaOfRectangleWithWidth:height:\n```\n\nTo call a handler with interleaved parameters, list the parameters in the same order as they are specified in the handler definition. Despite the resemblance to labeled parameters, the parameters may not be reordered. Also, the call must be explicitly sent to an object, even if the target object is the default, `it`. For example:\n\n```\nits foo:5 bar:105 --this works\ntell it to foo:5 bar:105 --as does this\nfoo:5 bar:105 --syntax error.\n```\n\n> <a id=\"//apple_ref/doc/uid/TP40000983-CH206-SW5\"></a>\n>\n> **Note:** The actual name of an interleaved-parameter handler is all the name parts strung together with underscores, and is equivalent to a handler defined using that name with positional parameters. For example, these two handler declarations are equivalent:\n>\n> ```\n> on tableView:t objectValueForTableColumn:c row:r\n> on tableView_objectValueForTableColumn_row_(t, c, r)\n> ```\n>\n> Given a compiled script, AppleScript will automatically translate between the two forms depending on whether or not the current system version supports interleaved parameters.\n\n<a id=\"//apple_ref/doc/uid/TP40000983-CH206-SW12\"></a>\n\n### Parameter Specifications\n\n> <a id=\"//apple_ref/doc/uid/TP40000983-CH206-SW18\"></a>\n>\n> **Note:** Parameter specifications are supported in OS X Yosemite v10.10 and later.\n\nThe parameter “name” in a handler definition may be a simple name, as shown above, or it may additionally specify a required class and, for labeled parameters, a default value. To specify a required class, follow the name with `as` *class* or `as {`*class*`,`…`}`. For example, you could declare a parameter to be specifically an integer like this:\n\n```\non factorial(x as integer)\n```\n\nThe effect is as if the handler began with `set x to x as integer`; if coercing the actual value to an integer fails, AppleScript throws an appropriate error, which may be caught with a `try` block. The class may be a list of classes, as described in [Operators Reference](../reference/ASLR_operators.md#//apple_ref/doc/uid/TP40000983-CH5g-124070).\n\nLabeled parameters may be declared with a default value by following the formal parameter name with `:`*literal*. Doing so makes the parameter optional when called. For example, this declares a `make` handler with a default value for the `with data` parameter:\n\n```\non make new theClass with data theData : missing value\n```\n\nThis handler can now be called without supplying a `with data` parameter; the handler would see `theData` set to the specified default `missing value`, which it could then test for and handle appropriately.\n\nA parameter may use both a type specification and a default value. For example, this declares a `make` handler with a `with properties` parameter that must be a record and has a default value of an empty record:\n\n```\non make new theClass with properties theProperties as record : {}\n```\n\n<a id=\"//apple_ref/doc/uid/TP40000983-CH206-SW11\"></a>\n\n### Recursive Handlers\n\n<a id=\"//apple_ref/doc/uid/TP40000983-CH206-DontLinkElementID_242\"></a><a id=\"//apple_ref/doc/uid/TP40000983-CH206-DontLinkElementID_243\"></a><a id=\"//apple_ref/doc/uid/TP40000983-CH206-DontLinkElementID_244\"></a>A *recursive handler* is a handler that calls itself. For example, this recursive handler generates a factorial. (The factorial of a number is the product of all the positive integers from 1 to that number. For example, 4 factorial is equal to 1 \\* 2 \\* 3 \\* 4, or 24. The factorial of 0 is 1.)\n\n```\non factorial(x)\n    if x &gt; 0 then\n        return x * factorial(x - 1)\n    else\n        return 1\n    end if\nend factorial\n \n-- To call factorial:\nfactorial(10)   --result: 3628800\n```\n\nIn the example above, the handler `factorial` is called once, passing the value `10`. The handler then calls itself recursively with a value of `x - 1`, or `9`. Each time the handler calls itself, it makes another recursive call, until the value of `x` is `0`. When `x` is equal to `0`, AppleScript skips to the `else` clause and finishes executing all the partially executed handlers, including the original `factorial` call.\n\nWhen you call a recursive handler, AppleScript keeps track of the variables and pending statements in the original (partially executed) handler until the recursive handler has completed. Because each call uses some memory, the maximum number of pending handlers is limited by the available memory. As a result, a recursive handler may generate an error before the recursive calls complete.\n\nIn addition, a recursive handler may not be the most efficient solution to a problem. For example, the factorial handler shown above can be rewritten to use a `repeat` statement instead of a recursive call, as shown in the example in `repeat with loopVariable (from startValue to stopValue)`.\n\n<a id=\"//apple_ref/doc/uid/TP40000983-CH206-SW10\"></a>\n\n### Errors in Handlers\n\n<a id=\"//apple_ref/doc/uid/TP40000983-CH206-DontLinkElementID_245\"></a>As with any AppleScript statements that may encounter an error, you can use a `try` statement to deal with possible errors in a handler. A `try` statement includes two collections of statements: one to be executed in the general case, and a second to be executed only if an error occurs.\n\nBy using one or more `try` statements with a handler, you can combine the advantages of reuse and error handling in one package. For a detailed example that demonstrates this approach, see [Working with Errors](../reference/ASLR_error_xmpls.md#//apple_ref/doc/uid/TP40000983-CH221-SW1).\n\n<a id=\"//apple_ref/doc/uid/TP40000983-CH206-SW4\"></a>\n\n### Passing by Reference Versus Passing by Value\n\n<a id=\"//apple_ref/doc/uid/TP40000983-CH206-DontLinkElementID_246\"></a>Within a handler, each parameter is like a variable, providing access to passed information. AppleScript passes all parameters by reference, which means that a passed variable is shared between the handler and the caller, as if the handler had created a variable using the `set` command. However, it is important to remember a point raised in [Using the copy and set Commands](ASLR_variables.md#//apple_ref/doc/uid/TP40000983-CH223-SW7): only mutable objects can actually be changed.\n\nAs a result, a parameter’s class type determines whether information is effectively passed by value or by reference:\n\n* For mutable objects (those whose class is `date`, `list`, `record`, or `script`), information is passed *by reference*:\n\n  If a handler changes the value of a parameter of this type, the original object is changed.\n* For all other class types, information is effectively passed *by value*:\n\n  Although AppleScript passes a reference to the original object, that object cannot be changed. If the handler assigns a new value to a parameter of this type, the original object is unchanged.\n\nIf you *want* to pass by reference with a class type other than `date`, `list`, `record`, or `script`, you can pass a `reference` object that refers to the object in question. Although the handler will have access only to a copy of the `reference` object, the specified object will be the same. Changes to the specified object in the handler will change the original object, although changes to the `reference` object itself will not.\n\n<a id=\"//apple_ref/doc/uid/TP40000983-CH206-SW1\"></a>\n\n### Calling Handlers in a tell Statement\n\n<a id=\"//apple_ref/doc/uid/TP40000983-CH206-DontLinkElementID_247\"></a>To call a handler from within a `tell` statement, you must use the reserved words `of me` or `my` to indicate that the handler is part of the script and not a command that should be sent to the target of the `tell` statement.<a id=\"//apple_ref/doc/uid/TP40000983-CH206-DontLinkElementID_248\"></a><a id=\"//apple_ref/doc/uid/TP40000983-CH206-DontLinkElementID_249\"></a>\n\nFor example, the following script calls the `minimumValue` handler defined in [Handlers with Positional Parameters](#//apple_ref/doc/uid/TP40000983-CH206-SW13) from within a `tell` statement. If this call did not include the words `of me`, it would cause an error, because AppleScript would send the `minimumValue` command to TextEdit, which does not understand that message.\n\n```\ntell front document of application \"TextEdit\"\n    minimumValue(12, 400) of me\n    set paragraph 1 to result as text\nend tell\n--result: The handler call is successful.\n```\n\nInstead of using the words `of me`, you could insert the word `my` before the handler call:\n\n```\nmy minimumValue(12, 400)\n```\n\n<a id=\"//apple_ref/doc/uid/TP40000983-CH206-SW14\"></a>\n\n## Handlers in Script Applications\n\n<a id=\"//apple_ref/doc/uid/TP40000983-CH206-DontLinkElementID_250\"></a><a id=\"//apple_ref/doc/uid/TP40000983-CH206-DontLinkElementID_251\"></a><a id=\"//apple_ref/doc/uid/TP40000983-CH206-DontLinkElementID_252\"></a>A *script application* is an application whose only function is to run the script associated with it. Script applications contain handlers that allow them to respond to commands. For example, many script applications can respond to the `run` command and the `open` command. A script application receives a `run` command whenever it is launched and an `open` command whenever another icon is dropped on its icon in the Finder. It can also contain other handlers to respond to commands such as `quit` or `print`.\n\nWhen saving a script in Script Editor, you can create a script application by choosing either Application or Application Bundle from the File Format options. Saving as Application results in a simple format that is compatible with Mac OS 9.<a id=\"//apple_ref/doc/uid/TP40000983-CH206-DontLinkElementID_253\"></a> Saving as Application Bundle results in an application that uses the modern bundle format, with its specified directory structure, which is supported back to OS X v10.3.<a id=\"//apple_ref/doc/uid/TP40000983-CH206-DontLinkElementID_254\"></a>\n\nWhen creating a script application, you can also specify whether a <a id=\"//apple_ref/doc/uid/TP40000983-CH206-DontLinkElementID_255\"></a><a id=\"//apple_ref/doc/uid/TP40000983-CH206-DontLinkElementID_256\"></a>startup screen should appear before the application runs its script. Whatever you write in the Description pane of the script window in Script Editor is displayed in the startup screen. <a id=\"//apple_ref/doc/uid/TP40000983-CH206-DontLinkElementID_257\"></a><a id=\"//apple_ref/doc/uid/TP40000983-CH206-DontLinkElementID_258\"></a>You can also specify in Script Editor whether a script application should stay open after running. The default is for the script to quit immediately after it is run.\n\nYou can run a script application from the Finder much like any other application. If it has a startup screen, the user must click the Run button or press the Return key before the script actually runs.\n\nConsider the following simple script\n\n```\ntell application \"Finder\"\n    close front window\nend tell\n```\n\nWhat this script does as a script application depends on what you specify when you save it. If you don’t specify a startup screen or tell it to stay open, it will automatically execute once, closing the front Finder window, and then quit.\n\nIf a script application modifies the value of a property, the changed value persists across launches of the application. For related information, see [Scope of Variables and Properties](ASLR_variables.md#//apple_ref/doc/uid/TP40000983-CH223-SW1).\n\nFor information about some common script application handlers, see the following sections:\n\n* [run Handlers](#//apple_ref/doc/uid/TP40000983-CH206-SW15)\n* [open Handlers](#//apple_ref/doc/uid/TP40000983-CH206-SW16)\n* [idle and quit Handlers for Stay-Open Applications](#//apple_ref/doc/uid/TP40000983-CH206-SW7)\n\nSee [Handler Reference](../reference/ASLR_handlers.md#//apple_ref/doc/uid/TP40000983-CH7g-163762) for syntax information.\n\n<a id=\"//apple_ref/doc/uid/TP40000983-CH206-SW15\"></a>\n\n### run Handlers\n\n<a id=\"//apple_ref/doc/uid/TP40000983-CH206-DontLinkElementID_259\"></a><a id=\"//apple_ref/doc/uid/TP40000983-CH206-DontLinkElementID_260\"></a>When you run a script or launch a script application, its `run` handler is invoked. A script’s `run` handler is defined in one of two ways:\n\n* As an implicit `run` handler, which consists of all statements declared outside any handler or nested `script` object in a script.\n\n  Declarations for properties and `global` variables are not considered statements in this context—that is, they are not considered to be part of an implicit `run` handler.\n* As an explicit `run` handler, which is enclosed within `on run` and `end` statements, similar to other handlers.<a id=\"//apple_ref/doc/uid/TP40000983-CH206-DontLinkElementID_261\"></a><a id=\"//apple_ref/doc/uid/TP40000983-CH206-DontLinkElementID_262\"></a><a id=\"//apple_ref/doc/uid/TP40000983-CH206-DontLinkElementID_263\"></a><a id=\"//apple_ref/doc/uid/TP40000983-CH206-DontLinkElementID_264\"></a>\n\nHaving both an implicit and an explicit `run` handler is not allowed, and causes a syntax error during compilation. If a script has no run handler (for example, a script that serves as a library of handlers, as described in [Parameter Specifications](#//apple_ref/doc/uid/TP40000983-CH206-SW12)), executing the script does nothing. However, sending it an explicit `run` command causes an error.\n\nThe following script demonstrates an implicit `run` handler. The script consists of a statement that invokes the `sayHello` handler, and the definition for the handler itself:\n\n```\nsayHello()\n \non sayHello()\n    display dialog \"Hello\"\nend sayHello\n```\n\nThe implicit `run` handler for this script consists of the statement `sayHello()`, which is the only statement outside the handler. If you save this script as a script application and then run the application, the script receives a `run` command, which causes it to execute the one statement in the implicit `run` handler.\n\nYou can rewrite the previous script to provide the exact same behavior with an explicit `run` handler:\n\n```\non run\n    sayHello()\nend run\n \non sayHello()\n    display dialog \"Hello\"\nend sayHello\n```\n\nWhether a script is saved as a script application or as a compiled script, its `run` handler is invoked when the script is run. You can also invoke a `run` handler in a script application from another script. For information about how to do this, see [Calling a Script Application From a Script](#//apple_ref/doc/uid/TP40000983-CH206-SW17).\n\n<a id=\"//apple_ref/doc/uid/TP40000983-CH206-SW16\"></a>\n\n### open Handlers\n\n<a id=\"//apple_ref/doc/uid/TP40000983-CH206-DontLinkElementID_265\"></a><a id=\"//apple_ref/doc/uid/TP40000983-CH206-DontLinkElementID_266\"></a>Mac apps, including script applications, receive an `open` command whenever the user drops file, folder, or disk icons on the application’s Finder icon, even if the application is already running.\n\nIf the script in a script application includes an `open` handler, the handler is executed when the application receives the `open` command. The `open` handler takes a single parameter which provides a list of all the items to be opened. Each item in the list is an`alias` object.\n\nFor example, the following `open` handler makes a list of the pathnames of all items dropped on the script application’s icon and saves them in the frontmost TextEdit document:\n\n```\non open names\n    set pathNamesString to \"\" -- Start with empty text string.\n    repeat with i in names\n        -- In this loop, you can perform operations on each dropped item.\n        -- For now, just get the name and append a return character.\n        set iPath to (i as text)\n        set pathNamesString to pathNamesString & iPath & return\n    end repeat\n    -- Store list in open document, to verify what was dropped.\n    tell application \"TextEdit\"\n        set paragraph 1 of front document to pathNamesString\n    end tell\n    return\nend open\n```\n\nFiles, folders, or disks are not moved, copied, or affected in any way by merely dropping them on a script application. However, the script application’s handler can tell Finder to move, copy, or otherwise manipulate the items. For examples that work with Finder items, see [Folder Actions Reference](../reference/ASLR_folder_actions.md#//apple_ref/doc/uid/TP40000983-CH219-SW2).\n\nYou can also run an `open` handler by sending a script application the `open` command. For details, see [Calling a Script Application From a Script](#//apple_ref/doc/uid/TP40000983-CH206-SW17).\n\n<a id=\"//apple_ref/doc/uid/TP40000983-CH206-SW7\"></a>\n\n### idle and quit Handlers for Stay-Open Applications\n\n<a id=\"//apple_ref/doc/uid/TP40000983-CH206-DontLinkElementID_267\"></a>By default, a script application that receives a `run` or `open` command handles that single command and then quits. In contrast, a stay-open script application (one saved as Stay Open in Script Editor) stays open after it is launched.\n\nA stay-open script application can be useful for several reasons:\n\n* Stay-open script applications can receive and handle other commands in addition to `run` and `open`. This allows you to use a script application as a script server that, when it is running, provides a collection of handlers that can be invoked by any other script.\n* Stay-open script applications can perform periodic actions, even in the background, as long as the script application is running.\n\nTwo particular handlers that stay-open script applications often provide are an `idle` handler and a `quit` handler.\n\n<a id=\"//apple_ref/doc/uid/TP40000983-CH206-SW8\"></a>\n\n#### idle Handlers\n\n<a id=\"//apple_ref/doc/uid/TP40000983-CH206-DontLinkElementID_268\"></a><a id=\"//apple_ref/doc/uid/TP40000983-CH206-DontLinkElementID_269\"></a>If a stay-open script application includes an `idle` handler, AppleScript sends the script application periodic `idle` commands—by default, every 30 seconds—allowing it to perform background tasks when it is not performing other actions.\n\nIf an `idle` handler returns a positive number, that number becomes the rate (in seconds) at which the handler is called. If the handler returns a non-numeric value, the rate is not changed. You can return 0 to maintain the default delay of 30 seconds.\n\nFor example, when saved as a stay-open application, the following script beeps every 5 seconds:\n\n```\non idle\n    beep\n    return 5\nend idle\n```\n\nThe result returned from a handler is just the result of the last statement, even if it doesn’t include the word `return` explicitly. (See `return` for more information.) For example, this handler gets called once a minute, because the value of the last statement is 60:\n\n```\non idle\n    set x to 10\n    beep\n    set x to x * 6  -- The handler returns the result (60).\nend idle\n```\n\n<a id=\"//apple_ref/doc/uid/TP40000983-CH206-SW9\"></a>\n\n#### quit Handlers\n\n<a id=\"//apple_ref/doc/uid/TP40000983-CH206-DontLinkElementID_270\"></a><a id=\"//apple_ref/doc/uid/TP40000983-CH206-DontLinkElementID_271\"></a>AppleScript sends a stay-open script application a `quit` command whenever the user chooses the Quit menu command or presses Command-Q while the application is active. If the script includes a `quit` handler, the statements in the handler are run before the application quits.\n\nA `quit` handler can be used to set script properties, tell another application to do something, display a dialog box, or perform almost any other task. If the handler includes a `continue quit` statement, the script application’s default quit behavior is invoked and it quits. If the `quit` handler returns before it encounters a `continue quit` statement, the application doesn’t quit.\n\n> <a id=\"//apple_ref/doc/uid/TP40000983-CH206-SW6\"></a>\n>\n> **Note:** The `continue` statement passes control back to the application’s default `quit` handler. For more information, see `continue`.\n\nFor example, this handler checks with the user before allowing the application to quit:\n\n```\non quit\n    display dialog \"Really quit?\" ¬\n        buttons {\"No\", \"Quit\"} default button  \"Quit\"\n    if the button returned of the result is \"Quit\" then\n        continue quit\n    end if\n    -- Without the continue statement, the application doesn't quit.\nend quit\n```\n\n<a id=\"//apple_ref/doc/uid/TP40000983-CH206-DontLinkElementID_8\"></a>\n\n**Warning:** \nIf AppleScript doesn’t encounter a `continue quit` statement while executing an `on quit` handler, it may seem to be impossible to quit the application. For example, if the handler shown above gets an error before the `continue quit` statement, the application won’t quit. If necessary, you can use Force Quit (Command-Option-Esc) to halt the application. <a id=\"//apple_ref/doc/uid/TP40000983-CH206-DontLinkElementID_272\"></a>\n\n<a id=\"//apple_ref/doc/uid/TP40000983-CH206-SW17\"></a>\n\n## Calling a Script Application From a Script\n\n<a id=\"//apple_ref/doc/uid/TP40000983-CH206-DontLinkElementID_273\"></a>A script can send commands to a script application just as it can to other applications. To launch a non-stay-open application and run its script, use a `launch` command followed by a `run` command, like this:\n\n```\nlaunch application \"NonStayOpen\"\nrun application \"NonStayOpen\"\n```\n\nThe `launch` command launches the script application without sending it an implicit `run` command. When the `run` command is sent to the script application, it processes the command, sends back a reply if necessary, and quits.\n\nSimilarly, to launch a non-stay-open application and run its `stringTest` handler (which takes a `text` object as a parameter), use a `launch` command followed by a `stringTest` command, like this:\n\n```\ntell application \"NonStayOpen\"\n    launch\n    stringTest(\"Some example text.\")\nend tell\n```\n\nFor information on how to create script applications, see [Handlers in Script Applications](#//apple_ref/doc/uid/TP40000983-CH206-SW14).<a id=\"//apple_ref/doc/uid/TP40000983-CH206-DontLinkElementID_274\"></a>\n\n  \n\n---\n\nCopyright © 2016 Apple Inc. All Rights Reserved. [Terms of Use](http://www.apple.com/legal/internet-services/terms/site.html) | [Privacy Policy](http://www.apple.com/privacy/) | Updated: 2016-01-25\n",
  "binary": false,
  "source_url": "https://developer.apple.com/library/archive/documentation/AppleScript/Conceptual/AppleScriptLangGuide/conceptual/ASLR_about_handlers.html",
  "sha256": "010b31a85da0326b0a7c8e3f0d5d5ceb15e1226bb424c3942dafd13de60c3757",
  "etag": null,
  "last_modified": null
}
